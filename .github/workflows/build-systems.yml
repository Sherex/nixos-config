name: Build NixOS Configurations

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [main]
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    strategy:
      matrix:
        action: [eval, build]
      fail-fast: true
    env:
      HOST_OUTPUT_DIR: host-outputs
    steps:
      - uses: actions/checkout@v5
      - uses: cachix/install-nix-action@v31

      - uses: mathio/gha-cleanup@ce9480b80d151ff36572df0d3c54aef2653e6054
        if: matrix.action == 'build'
        with:
          remove-browsers: true

      - name: ${{ matrix.action == 'eval' && 'Evaluate' || 'Build' }} configurations and check for warnings/errors
        id: nix-action
        env:
          ACTION: ${{ matrix.action }}
        run: |
          nix_cmd_failed=false
          has_issues=false
          all_output=""
          mkdir -p $HOST_OUTPUT_DIR

          for host in $(nix flake show --json . | jq -r '.nixosConfigurations | keys[]'); do
            echo "::group::${{ matrix.action == 'eval' && 'Evaluating' || 'Building' }} $host..."

            echo "Something failed. Check runner output." > $HOST_OUTPUT_DIR/$host.log

            output_file=$(mktemp)
            host_has_issues=false

            # Execute the command with pipe and capture the original command's return code
            nix ${{ matrix.action }} .#nixosConfigurations.${host}.config.system.build.toplevel 2>&1 | tee "$output_file"
            cmd_rc=${PIPESTATUS[0]}  # Get exit code of the nix command, not tee

            # Check if the command failed
            if [ $cmd_rc -ne 0 ]; then
              nix_cmd_failed=true
              has_issues=true
              host_has_issues=true
              echo "::error::Command failed with exit code $cmd_rc for host $host"
            fi

            # Check for warnings/errors in output, excluding exceptions
            exceptions_pattern="warning: download buffer is full"
            if grep -E "(warning|error)" -i "$output_file" | grep -v -E -i "$exceptions_pattern"; then
              has_issues=true
              host_has_issues=true
              echo "::warning::Warnings or errors found in output for host $host"
            fi

            echo -n "" > $HOST_OUTPUT_DIR/$host.log

            if [ "$host_has_issues" = true ]; then
              grep -E "(warning|error)" -i --context 10 "$output_file" | grep -v -E -i "$exceptions_pattern" > $HOST_OUTPUT_DIR/$host.log
            fi

            echo "::endgroup::"
          done

          echo "has_issues=$has_issues" >> $GITHUB_OUTPUT

          if [ "$nix_cmd_failed" = true ]; then
            exit 1
          fi

      - name: Post ${{ matrix.action }} results as comment (PR only)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          HAS_ISSUES: ${{ steps.nix-action.outputs.has_issues }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const hostOutputsDir = path.join(process.cwd(), process.env.HOST_OUTPUT_DIR);
            let commentBody = '## NixOS Configuration ${{ matrix.action == 'eval' && 'Evaluation' || 'Build' }} Results\n\n';

            if (!fs.existsSync(hostOutputsDir) || fs.readdirSync(hostOutputsDir).length === 0) {
              commentBody += 'No host output files found in host-outputs directory.\n';
              commentBody += '*Posted from GitHub Actions workflow*';
              return;
            }

            const files = fs.readdirSync(hostOutputsDir);
            const logFiles = files.filter(f => f.endsWith('.log'));
            const maxCharsPerFile = Math.floor(65000 / logFiles.length);

            logFiles.forEach(file => {
              const hostname = file.replace('.log', '');
              const filePath = path.join(hostOutputsDir, file);
              const fileContent = fs.readFileSync(filePath, 'utf8');
              const previousStepFailed = process.env.HAS_ISSUES === 'true';
              const success = !fileContent.trim();

              let statusMessage = '';
              if (!previousStepFailed && !success) {
                statusMessage = '⚠️';
              } else if (success) {
                statusMessage = '✅';
              } else {
                statusMessage = '❌';
              }

              commentBody += `### ${statusMessage} ${hostname}\n`;

              let truncatedContent = fileContent;
              if (fileContent.length > maxCharsPerFile) {
                // Take last maxCharsPerFile characters
                truncatedContent = fileContent.slice(-maxCharsPerFile);
              }

              if (!success) {
                commentBody += '```log\n';
                commentBody += truncatedContent;
                commentBody += '\n```\n\n';
              };
            });

            commentBody += '*Posted from GitHub Actions workflow*';
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.data.find(comment =>
              comment.user.login === 'github-actions[bot]' &&
              comment.body.includes('NixOS Configuration ${{ matrix.action == 'eval' && 'Evaluation' || 'Build' }} Results')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }
