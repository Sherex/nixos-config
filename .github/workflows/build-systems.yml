name: Build NixOS Configurations

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [main]
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    strategy:
      matrix:
        action: [eval, build]
      fail-fast: true
    env:
      HOST_OUTPUT_DIR: host-outputs
      NIX_SIGN_PRIVATE_KEY: ${{ secrets.NIX_SIGN_PRIVATE_KEY }}
      NIX_SIGN_PRIVATE_KEY_FILE: /tmp/cache-priv-key.pem
      AWS_ACCESS_KEY_ID: ${{ vars.S3_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.S3_SECRET_KEY }}
      AWS_REGION: garage
      NIX_PERSONAL_BINARY_CACHE: s3://nix-cache?endpoint=${{ secrets.S3_ENDPOINT }}&region=garage&scheme=https
      NIX_PERSONAL_BINARY_CACHE_PUBLIC_KEY: ${{ vars.S3_PUBLIC_KEY }}
    steps:
      - uses: actions/checkout@v6
      - name: Create Nix signing key file
        run: |
          cat >"$NIX_SIGN_PRIVATE_KEY_FILE" <<'EOF'
          ${{ secrets.NIX_SIGN_PRIVATE_KEY }}
          EOF
      - name: Setup S3 credentials
        run: |
          # For daemon running as root
          sudo -i aws configure set aws_access_key_id "${AWS_ACCESS_KEY_ID}"
          sudo -i aws configure set aws_secret_access_key "${AWS_SECRET_ACCESS_KEY}"
          sudo -i aws configure set region "${AWS_REGION}"
          # For nix client commands (Can also use the ENV vars)
          aws configure set aws_access_key_id "${AWS_ACCESS_KEY_ID}"
          aws configure set aws_secret_access_key "${AWS_SECRET_ACCESS_KEY}"
          aws configure set region "${AWS_REGION}"
      - uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            secret-key-files = ${{ env.NIX_SIGN_PRIVATE_KEY_FILE }}
            extra-substituters = ${{ env.NIX_PERSONAL_BINARY_CACHE }}
            extra-trusted-public-keys = ${{ env.NIX_PERSONAL_BINARY_CACHE_PUBLIC_KEY }}

      - uses: mathio/gha-cleanup@ce9480b80d151ff36572df0d3c54aef2653e6054
        if: matrix.action == 'build'
        with:
          remove-browsers: true

      - name: ${{ matrix.action == 'eval' && 'Evaluate' || 'Build' }} configurations and check for warnings/errors
        id: nix-action
        env:
          ACTION: ${{ matrix.action }}
        run: |
          nix_cmd_failed=false
          has_issues=false
          all_output=""
          mkdir -p $HOST_OUTPUT_DIR

          for host in $(nix flake show --json . | jq -r '.nixosConfigurations | keys[]'); do
            echo "::group::${{ matrix.action == 'eval' && 'Evaluating' || 'Building' }} $host..."

            echo "Something failed. Check runner output." > $HOST_OUTPUT_DIR/$host.log

            output_file=$HOST_OUTPUT_DIR/$host.log
            output_file_error=$HOST_OUTPUT_DIR/$host.error-log
            host_has_issues=false

            touch $output_file $output_file_error

            # Execute the command with pipe and capture the original command's return code
            nix ${{ matrix.action }} .#nixosConfigurations.${host}.config.system.build.toplevel 2>&1 | tee "$output_file"
            cmd_rc=${PIPESTATUS[0]}  # Get exit code of the nix command, not tee

            # Check if the command failed
            if [ $cmd_rc -ne 0 ]; then
              nix_cmd_failed=true
              has_issues=true
              host_has_issues=true
              echo "::error::Command failed with exit code $cmd_rc for host $host"
            fi

            # Check for warnings/errors in output, excluding exceptions
            exceptions_pattern="warning: download buffer is full"
            if grep -E "(warning|error)" -i "$output_file" | grep -v -E -i "$exceptions_pattern"; then
              has_issues=true
              host_has_issues=true
              echo "::warning::Warnings or errors found in output for host $host"
            fi

            if [ "$host_has_issues" = true ]; then
              grep -E "(warning|error)" -i --context 10 "$output_file" | grep -v -E -i "$exceptions_pattern" > $output_file_error

              status_symbol="⚠️"
              [ "$nix_cmd_failed" = true ] && status_symbol="❌"

              {
                echo "### $status_symbol $host"
                echo
                echo "<details>"
                echo "<summary>Warnings/Errors</summary>"
                echo
                echo '```log'
                cat "$output_file_error"
                echo '```'
                echo
                echo "</details>"
                echo
              } >> "$GITHUB_STEP_SUMMARY"
            else
              echo "### ✅ $host" >> $GITHUB_STEP_SUMMARY
            fi

            echo "::endgroup::"
          done

          echo "has_issues=$has_issues" >> $GITHUB_OUTPUT
          echo "build_failed=$nix_cmd_failed" >> $GITHUB_OUTPUT

          if [ "$nix_cmd_failed" = true ]; then
            exit 1
          fi

      - name: Post ${{ matrix.action }} results as comment (PR only)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v8
        env:
          HAS_ISSUES: ${{ steps.nix-action.outputs.has_issues }}
          BUILD_FAILED: ${{ steps.nix-action.outputs.build_failed }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const hostOutputsDir = path.join(process.cwd(), process.env.HOST_OUTPUT_DIR);
            let commentBody = '## NixOS Configuration ${{ matrix.action == 'eval' && 'Evaluation' || 'Build' }} Results\n\n';

            if (!fs.existsSync(hostOutputsDir) || fs.readdirSync(hostOutputsDir).length === 0) {
              commentBody += 'No host output files found in host-outputs directory.\n';
              commentBody += '*Posted from GitHub Actions workflow*';
              return;
            }

            const files = fs.readdirSync(hostOutputsDir);
            const logFiles = files.filter(f => f.endsWith('.error-log'));
            const maxCharsPerFile = Math.floor(65000 / logFiles.length);

            logFiles.forEach(file => {
              const hostname = file.replace('.log', '');
              const filePath = path.join(hostOutputsDir, file);
              const fileContent = fs.readFileSync(filePath, 'utf8');
              const previousStepFailed = process.env.BUILD_FAILED === 'true';
              const errorFileHasContent = fileContent.trim().length > 0;

              let statusMessage = '';
              if (!previousStepFailed && errorFileHasContent) {
                statusMessage = '⚠️';
              } else if (!previousStepFailed) {
                statusMessage = '✅';
              } else {
                statusMessage = '❌';
              }

              commentBody += `### ${statusMessage} ${hostname}\n`;

              let truncatedContent = fileContent;
              if (fileContent.length > maxCharsPerFile) {
                // Take last maxCharsPerFile characters
                truncatedContent = fileContent.slice(-maxCharsPerFile);
              }

              if (errorFileHasContent) {
                commentBody += '```log\n';
                commentBody += truncatedContent;
                commentBody += '\n```\n\n';
              };
            });

            commentBody += '*Posted from GitHub Actions workflow*';
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.data.find(comment =>
              comment.user.login === 'github-actions[bot]' &&
              comment.body.includes('NixOS Configuration ${{ matrix.action == 'eval' && 'Evaluation' || 'Build' }} Results')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }

      - name: Upload built outputs to binary cache
        if: github.ref == 'refs/heads/main' && matrix.action == 'build'
        continue-on-error: true
        run: |
          set -euo pipefail

          for host in $(nix flake show --json . | jq -r '.nixosConfigurations | keys[]'); do
            nix copy --to "$NIX_PERSONAL_BINARY_CACHE" .#nixosConfigurations.$host.config.system.build.toplevel 2>&1 | tee -a upload.log
          done

          mapfile -t UPLOADS < <(grep 'copying path' upload.log | sed "s/.*copying path '\([^']*\)'.*$/\1/" | sort | uniq)
          UPLOAD_COUNT=${#UPLOADS[@]}

          {
            echo "---"
            echo "### Uploaded $UPLOAD_COUNT outputs to binary cache"
            echo
            echo "<details>"
            echo "<summary>List of outputs</summary>"
            echo
            echo '```'
            cat "upload.log"
            echo '```'
            echo
            echo "</details>"
            echo
          } >> "$GITHUB_STEP_SUMMARY"
